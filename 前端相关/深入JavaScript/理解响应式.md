# 理解响应式

## 何为响应式

大部分人对「响应式」设计的初体验是 Excel —— 在表格内输入公式，当公式依赖的单元格的值发生变动时，公式产生的值也会实时更新。反映到前端中，响应式一般指：

- 数据的更新会实时反映到用户界面（即 DOM）上，对应着 Vue 中的模板语法
- 数据的更新会使得依赖它的数据跟着更新，对应着 Vue 中的 `computed` 计算属性
- 数据的更新会触发一些依赖它的逻辑，对应着 Vue 中的 `watch`、`watchEffect` 监听器

这三件事的核心都是**数据的变动**——数据的变动会使得依赖它的内容一起变动。再进一步，这三件事其实是一件事：**数据绑定了逻辑（函数）。**

- 模板的本质是 VNode，数据的更新导致生成 VNode 的函数重新调用
- 数据的更新导致 `computed` 函数重新调用，产生了新的值
- 数据更新触发的逻辑，本质上也是函数

## 监听数据的变动

如何监听数据的变动？首先要明确一个点：**JS 没有提供任何方式追踪变量的读取和写入，但是 JS 可以追踪对象属性的读取和写入**。

所以有两种办法：

1. 把一个值包装成对象，通过 `obj.value` 读取和写入值
2. 干脆将值都写在对象属性中，直接监控这个对象

这两种方式分别对应了 Vue 的 `ref` 和 `reactive` API。

对于第一种情况，只有一个 `value` 属性需要监听，我们可以通过 [`Object.defineProperty` 方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 来定义某个属性的 getter 和 setter：

```ts
type Ref<T> = {
  value: T;
};

function ref<T>(initial: T): Ref<T> {
  const refObj = <Ref<T>>{};
  return Object.defineProperty(refObj, "value", {
    get: () => {
      console.log("get:", initial);
      return initial;
    },
    set: (v) => {
      console.log("set:", v);
      initial = v;
      return v;
    },
  });
}

const a = ref(1);
console.log(a.value);
// get: 1
// 1
a.value = 2;
// set: 2
console.log(a.value);
// get: 2
// 2
```

对于第二种情况，监听整个对象的属性，可以用 [Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 实现：

```ts
type Reactive<T extends object> = T;

function reactive<T extends object>(obj: T): Reactive<T> {
  const reactiveObj = new Proxy(obj, {
    get(target: T, key: string) {
      console.log("get:", key);
      return key in target ? target[key] : undefined;
    },
    set(target: T, key: string, value: any) {
      console.log("set:", key, value);
      target[key] = value;
      return value;
    },
  });
  return reactiveObj;
}

const rObj = reactive({ foo: "foo!", bar: 2 });
console.log(rObj.foo);
// get: foo
// foo!
rObj.bar++;
// get: bar
// set: bar 3
```

那么目前我们只是实现了 `ref` 和 `reactive` 两个存放数据的容器，还没有在读写属性时执行什么逻辑。

接下来我们需要一张表来保存每个响应式数据所对应的函数，这些函数需要在响应式数据修改时执行（简单起见，我们就不考虑这些函数的传参问题了）。建立一个 WeakMap `effectMap` 来存储：

```ts {1-2}
// [!code escape-format]
type Dependency = Ref<any> | Reactive<object>;
const effectMap = new WeakMap<Dependency, Set<Function>>();

function ref<T>(initial: T): Ref<T> {
  const refObj = <Ref<T>>{};
  return Object.defineProperty(refObj, "value", {
    // ...
    set: (v) => {
      // ...
      if (effectMap.has(refObj))
        // [!code ++]
        effectMap.get(refObj)!.forEach((fn) => fn()); // [!code ++]
      return v;
    },
  });
}

function reactive<T extends object>(obj: T): Reactive<T> {
  const reactiveObj = new Proxy(obj, {
    // ...
    set(target: T, key: string, value: any) {
      // ...
      if (effectMap.has(reactiveObj))
        // [!code ++]
        effectMap.get(reactiveObj)!.forEach((fn) => fn()); // [!code ++]
      return value;
    },
  });
  return reactiveObj;
}
```

## 响应式 API 的实现

有了上面这些，实现响应式 API 就比较容易了 —— 只要按需将函数加入到 `effectMap` 即可。

### `watch`

最简单的就是 `watch`：

```ts
function watch(dep: Dependency | Dependency[], fn: () => void) {
  const depArr = dep instanceof Array ? dep : [dep];
  depArr.forEach((d) => {
    if (!effectMap.has(d)) effectMap.set(d, new Set());
    effectMap.get(d)!.add(fn);
  });
}
```

### `watchEffect`

`watchEffect` 会复杂一些，因为要监听函数调用过程中哪些响应式数据被**读取**了。我们可以准备一个 flag，当需要「录制」数据读取情况时将 flag 设为 true，让 getter 们去记录读取情况：

```ts {7-9}
const recording = {
  isRecording: false,
  refSet: new Set<Dependency>(),
};

function watchEffect(fn: () => void) {
  recording.isRecording = true; // 启动「录制」
  fn();
  recording.isRecording = false; // 停止「录制」
  recording.refSet.forEach((ref) => {
    if (!effectMap.has(ref)) effectMap.set(ref, new Set());
    effectMap.get(ref)!.add(fn);
  });
  recording.refSet.clear();
}
```

并修改刚刚的 `ref` 和 `reactive`：

```ts
function ref<T>(initial: T): Ref<T> {
  const refObj = <Ref<T>>{};
  return Object.defineProperty(refObj, "value", {
    get: () => {
      console.log("get:", initial);
      if (recording.isRecording) recording.refSet.add(refObj); // [!code ++]
      return initial;
    },
    // ...
  });
}

function reactive<T extends object>(obj: T): Reactive<T> {
  const reactiveObj = new Proxy(obj, {
    get(target: T, key: string) {
      console.log("get:", key);
      if (recording.isRecording) recording.refSet.add(reactiveObj); // [!code ++]
      return key in target ? target[key] : undefined;
    },
    // ...
  });
  return reactiveObj;
}
```

### `computed`

`computed` API 可以基于刚刚的 `watchEffect`：

```ts
function computed<T>(fn: () => T) {
  const refObj = ref(<T>null);
  watchEffect(() => (refObj.value = fn()));
  return refObj;
}
```

至此，我们就实现了一个「猴版」Vue 响应式 API。当然，具体实现和 Vue 源码肯定还是有区别，很多边界情况也没有考虑，但是作为一个用来理解响应式实现原理的示例，应该还是足够的。

::: details 完整的示例代码

```ts
type Ref<T> = {
  value: T;
};
type Reactive<T extends object> = T;
type Dependency = Ref<any> | Reactive<object>;

const recording = {
  isRecording: false,
  refSet: new Set<Dependency>(),
};

const effectMap = new WeakMap<Dependency, Set<Function>>();

function ref<T>(initial: T): Ref<T> {
  const refObj = <Ref<T>>{};
  return Object.defineProperty(refObj, "value", {
    get: () => {
      console.log("get:", initial);
      if (recording.isRecording) recording.refSet.add(refObj);
      return initial;
    },
    set: (v) => {
      console.log("set:", v);
      initial = v;
      if (effectMap.has(refObj)) effectMap.get(refObj)!.forEach((fn) => fn());
      return v;
    },
  });
}

function reactive<T extends object>(obj: T): Reactive<T> {
  const reactiveObj = new Proxy(obj, {
    get(target: T, key: string) {
      console.log("get:", key);
      if (recording.isRecording) recording.refSet.add(reactiveObj);
      return key in target ? target[key] : undefined;
    },
    set(target: T, key: string, value: any) {
      console.log("set:", key, value);
      target[key] = value;
      if (effectMap.has(reactiveObj))
        effectMap.get(reactiveObj)!.forEach((fn) => fn());
      return value;
    },
  });
  return reactiveObj;
}

function watch(dep: Dependency | Dependency[], fn: () => void) {
  const depArr = dep instanceof Array ? dep : [dep];
  depArr.forEach((d) => {
    if (!effectMap.has(d)) effectMap.set(d, new Set());
    effectMap.get(d)!.add(fn);
  });
}

function watchEffect(fn: () => void) {
  recording.isRecording = true;
  fn();
  recording.isRecording = false;
  recording.refSet.forEach((ref) => {
    if (!effectMap.has(ref)) effectMap.set(ref, new Set());
    effectMap.get(ref)!.add(fn);
  });
  recording.refSet.clear();
}

function computed<T>(fn: () => T) {
  const refObj = ref(<T>null);
  watchEffect(() => (refObj.value = fn()));
  return refObj;
}
```

:::

你可以自己试着玩一玩：

```ts
const a = ref(1);
watchEffect(() => {
  console.log("eff:", a.value);
});
// get: 1
// eff: 1
a.value = 5;
// set: 5
// get: 5
// eff: 5
a.value += 3;
// get: 5
// set: 8
// get: 8
// eff: 8
```

## 响应式的常见问题

玩完了吗？玩完了我们继续聊。
