# 四月份训练手记

## 4.1 - 1 - [Problem - H - Codeforces](https://codeforces.com/contest/2065/problem/H)

#### 思路

这道题主要是考察线段树的应用

不难发现，对于某一个字符串（不做修改），我们可以通过 DP 的方法来得到答案，只需要维护在某个点之前：

- 以 $1$ 结尾的答案总贡献和子串数量
- 以 $0$ 结尾的答案总贡献和字串数量

至于转移方法，我们只需要在新加入一个不同字符的时候更新贡献与子序列数量即可

那为了支持修改，我们需要使用线段树来维护以上信息，但线段树维护的是区间，而不是前缀

所以我们需要对子串的开头和结尾都进行分类

并且在合并的时候，考虑所有情况的贡献，减去那些中间字符相同（比如 $01$ 和 $10$ ）的两个串合并后的贡献是两个串的贡献相加再 $-1$

#### 收获&反思

线段树的又一应用方法

对于区间上贡献具有一定的**“可加性”**或者**“分类可加性”**，的时候，就要考虑使用线段树来维护

对于“线段树是在维护幺半群上的信息”这句话的理解又加深了一点

## 4.1 - 2 - [Problem - I - Codeforces](https://codeforces.com/contest/2045/problem/I)

#### 思路

我们先考虑，如果是朴素的贪心，怎么来解决问题：

- 首先对于每一个有序对 $(x,y)$ 都可以用贪心统计答案：先遇到哪个字符，我就先加入序列
- 不难证明，这样找到的序列一定是最长的

思考一下，这样的贪心解法对于我们的解答有什么启发呢？

进一步地说，在这种贪心策略下，某一个位置的字符，在什么情况下才会被“收录”到某一个有序对 $(x,y)$ 的答案当中，进而对最终答案产生贡献呢？

考虑到我们贪心的过程，答案也是显然的：

- 在某一轮贪心中，只有这个字符与前一个相同字符之间，有一个目标字符（有序对中的另一个字符），这个字符才会被“收录”
- 如果没有前一个字符（首次出现）则一定会被收录

那我们的贡献统计就变得简单起来了，对于每一个位置：

- 如果是第一次出现，一定会产生贡献， $cnt=m-1$ 之所以要减一是因为它不能和自己构成有序对（题目限制）
- 否则，我们找它和前一个相同字符之间，统计其中不同字符的个数，就是它的贡献值

问题又转化为了：如何统计区间上的不同字符个数

对于普适的做法，我们可以使用主席树（可持久化权值线段树）来统计区间上不同数值的个数

但这道题不需要那么复杂，因为我们要求的区间具有 右节点严格非降的后缀区间 性质，在这个条件下，就可以记录每个字符最后一次出现的位置，并且标记为 $1$ ，然后树状数组维护区间和与单点修改就可以了

#### 收获&反思

思路相当值得学习！

这道题的几个关键点：

- 用贪心简化问题，便于考虑
- 用贡献法转化问题，使得枚举量变为 $O(n)$ 
- 利用待统计区间的特殊性质，用树状数组完成区间字符种数的统计

## 4.2 - 1 - [Problem - G2 - Codeforces](https://codeforces.com/contest/1986/problem/G2)

*超级神秘好题*

#### 思路

我们考虑对于一组数 $(p_i,p_j)$ ，它们满足要求的条件是 $ij\mid p_ip_j$ 

不难注意到，$p_i$ 和 $i$ 总是同时出现的，所以不妨预处理一下，令 $x_i=\frac i{\gcd(i,p_i)}$ ，$y_i=\frac {p_i}{\gcd(i,p_i)}$ ，其中有 $x_i \perp y_i$ 

于是题目要的条件就变成了 $x_ix_j\mid y_iy_j$ 由于 $x_i\perp y_i$ 并且 $x_j\perp y_j$ 于是条件进一步变为：

- $x_i\mid y_j$ 并且 $x_j\mid y_i$

一个很自然的想法就是，我们枚举所有可能的 $x$ ，然后枚举是 $x$ 的倍数的 $y$ 的值，对于这些 $y$ 来检查，然后统计答案

但是这样子做有一个问题：我们前两层枚举的时间复杂度是 $O(n\log n)$ 的，但是有可能对于某一个很小的 $x$ ，有相当多的点，这个时候检查的时间复杂度就会超出限制

###### 如何才能保证时间复杂度严格低于限制呢？

我们考虑上一个方案的缺点是什么，就是对于一个体量很大的 $x$ （也就是有很多个 $i$ 都满足 $x_i=x$），我们在枚举可能的 $j$ 的时候，需要对每一个 $i$ 都去判断，效率是很低的

考虑使用预处理来提高效率

我们的检查是在做什么？是在检查每一个可能的 $j$ ，有几个 $i$ 能满足 $x_j\mid y_i$ ，也就是说其中有几个 $y_i$ 的因数包括了 $x_j$ ，那我们就可以提前统计出每一个因数出现的次数，然后每次直接统计贡献

###### 为什么这样时间复杂度是正确的？

首先每个数只会在初始阶段被枚举一次，对应的就是二层的枚举量严格小于 $n\log n$，同时考虑枚举因子的开销，也是每一个 $y_i$ 只会被枚举一次，所以枚举因子的开销也严格小于 $n\log n$ ，证明完毕

#### 收获&反思

这道题做法难度不高，但是其中涉及到了较为复杂的时间复杂度优化想法与时间复杂度的正确性证明

解决的方法有很多，但是其中相当一部分可以被精心构造的数据卡到 $TLE$ ，所以需要我们牢固掌握时间复杂度的分析和优化手段，设计出严格时间复杂度的 $Solution$  

## 4.3 - 1 - [Problem - E3 - Codeforces](https://codeforces.com/contest/1970/problem/E3)

*这次会用倍增了*

#### 思路

看到这道题就想到了应该可以倍增，因为：

- $n$ 的范围巨大，显然无法直接计算
- 题目中对于转移的限制较低，可能可以转化为统一计算的方案

但是倍增的对象还需要精心选择：

- 如果选择每个木屋的方案数，在统计的时候并不方便，而且时间会超出限制
- 如果选择第 $i$ 天的方案数，则没有有效的转化手段

这个时候应该思考到：什么东西状态量少，可以倍增（可以转移），并且可以导出最终答案呢？

不难发现，如果抛开限制，我们既然每天都要前往湖心岛，那我们就可以把这个时候当作一个节点，从湖心岛出发之后再回来的方案数是可以计算的，还支持倍增

但是考虑到题目中的条件，那就要求我们前一次到达湖心岛与后一次离开必然有一次走短路，所以就可以分类维护出发与回来走的路的种类，然后进行条件转移

最后的答案就是考虑从 $1$ 号房子出发，有多少种方案到达湖心岛，最后一天又有多少种方法可以走到其他房子

#### 收获&反思

合理设计倍增的对象，就可以变魔法！

## 4.3 - 2 - [Problem - B2 - Codeforces](https://codeforces.com/contest/1967/problem/B2)

#### 思路

因为 $a+b\mid b\gcd(a,b)$ ，两边同除 $\gcd(a,b)$ 后即为 $a'+b'\mid b'\gcd(a,b)$，其中 $a'\perp b'$ 

所以也有 $b'\perp a'+b'$ ，所以就有 $a'+b'\mid \gcd(a,b)$ 

于是我们就可以枚举互素的 $a',b'$，，再枚举 $\gcd(a,b)=k(a'+b')$ 因为要满足：
$$
\left\{
\begin{aligned}
&a=a'\times \gcd(a,b)=ka'(a'+b')\le n\\
&b=b'\times \gcd(a,b)=kb'(a'+b')\le m
\end{aligned}
\right.
$$
 所以合法的 $k$ 的数目就是：
$$
\min\{\lfloor\frac{n}{a'(a'+b')}\rfloor,\lfloor\frac{m}{b'(a'+b')}\rfloor\}
$$
不难发现这里的 $a,b$ 均大于 $a'^2,b'^2$ ，所以我们只需要在 $\sqrt n,\sqrt m$ 的范围内分别枚举即可，时间复杂度 $O(\sqrt{nm})$

#### 收获&反思

善于运用互素结论，可以更好的分析题目

## 4.4 - 1 - [Problem - D - Codeforces](https://codeforces.com/contest/2086/problem/D)

#### 思路

*赛时脑子抽了*

其实就是一个背包$dp$，很简单地考虑 $dp[i][j]$ 是只考虑前 $i$ 种字母，其中有 $j$ 个奇数位已经被占据的方案数

记每个字母的数量是 $cnt[i]$ ，字母总数是 $sum$ ，$cnt[i]$ 的前缀和是 $pref[i]$

那转移方程就是：
$$
dp[i][j]=
\left\{
	\begin{aligned}
		&dp[i-1][j]\times \binom {\lceil\frac {sum}2\rceil-(pref[i]-j)+cnt[i]}{cnt[i]}\\
		&dp[i-1][j-cnt[i]]\times \binom{\lfloor\frac {sum}2\rfloor-j+cnt[i]}{cnt[i]}
	\end{aligned}
\right.
$$
需要注意其中一些项的转移条件

第二种方法就是，先用数学方法推导发现奇偶性排列的方案与最终字符串排列的方案无关，故可以直接先求出方案数，最后再计算组合数，本质上是一样的

#### 收获&反思

需要针对题目选择不同的解决方案

## 4.4 - 2 - [Problem - D - Codeforces](https://codeforces.com/contest/2018/problem/D)

#### 思路

不难注意到，对于最大值我们是一定要选取的，证明如下：

- 如果不选最大值，那么至少会带来一点减益
- 此时去选最大值，最小值一定非降，$siz$ 至多减一，使用一定不会更劣

那么我们就可以考虑枚举我们要取到的最小值，我们可以把每一个数按照大小先排序，然后从大到小加入

我们可以用并查集来维护答案：

- 对于每一个连成一段的区间，我们最优就是每隔一个去选取，并且区间长度为奇数的时候，要从第一个开始选取
- 我们可以记录在这些区间里最大值出现了几次（偶数长度区间就取较大值）然后判断需不需要牺牲一个位置来取最大值
- 每一轮维护之后，答案就是 $max+min+siz$ 这里的 $siz$ 是各个区间统计的可以取到的最多格子数量，并且经过了判断是否需要减一（牺牲一个格子保证最大值）

#### 收获&反思

维护最大值能不能被取到的时候，可以维护区间数量而不只是“能或不能”，这样更方便维护

对于这样取最值的题目，充分考虑性质之后，可以使用动态方法维护+枚举部分条件的方法求解

## 4.4 - 3 - [Problem - H - Codeforces](https://codeforces.com/contest/1971/problem/H)

#### 思路

这是经典的`2-SAT`问题，每个元素选与不选就是每个 $a_i$ 的值是 $1$ 还是 $-1$ 

然后，对应的，`2-SAT` 问题的子句就是对应的 B 矩阵中的每一个纵列，任何两个元素不能同时为 $-1$

#### 收获&反思

学习了 `2-SAT`

使用 Tarjan-SCC 求解

## 4.5 - 1 - [Problem - E - Codeforces](https://codeforces.com/contest/519/problem/E)

#### 思路

很简单，一眼就是求 $kth$ 祖先的题目

首先判断，对于两个点，如果他们之间的距离是奇数，一定无解

其次，如果两个点重合，则任意一个点都可行

再次就是，如果两个点深度相同，那么他们简单路径的中点（也就是 $LCA$） 的子树外的所有节点也都可以满足条件

其他的点，也就是有解并且到 $LCA$ 的距离不相等，就只有其简单路径的中点的子树上，除去包含两点的子树后剩下的节点

#### 收获&反思

倍增求祖先的简单运用，没什么好说的

## 4.5 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/2084/problem/E)

#### 思路

赛时没做出来纯糖哇

这是一个“合理拆贡献”的好例题，如果不能合理拆分贡献，就会使得这道题很难做（当然你会NTT大力出奇迹当我没说）

首先明确题意：对于所有可能的排列，求出所有区间 $mex$ 值的总和

一个很自然的想法是，我们考虑对于每个区间，枚举其可能的 $mex$ 值并且统计对应的排列，但是这是 $O(n^3)$ 的，时间接受不了

所有我们需要改变求解思路，考虑贡献法

这里有一个很巧妙的转化，我们把所有区间的 $mex$ 值总和转化为：
$$
\sum_{i=0}^n包含所有[0,i]中的数的集合数量
$$
为什么这样是对的呢？不难发现，$mex$ 值为 $k$ 的区间，会对于 $i=[0,k-1]$ 均成立，也就是产生 $k$ 次贡献，所以这样计算是等价的

这是贡献法中的一种“差分思想”，适用于条件和贡献具有一定单调性的情形

###### 那我们该怎么统计这类集合呢？又该怎么求解呢？

首先我们注意到，如果要满足前 $k$ 个条件，必须要有前 $k$ 个数，并且其中一些数已经被固定了（在数组中给出）

所以我们在考虑区间可行的最大 $mex$ 值的时候，需要注意有没有在数组中的，小于 $k$ 值的数不被包含在区间里，如果有的话，那么我们的 $mex$ 值无论如何也不能超过这个数

换而言之，如果出现在数组中小于 $k$ 的所有数都被包含在了这个区间里，那么只要有足够多的空位，他是可以满足任何 $mex\le k$ 的条件的

所以，我们就可以统计出 $cnt[i][j]$ ，表示数组中小于 $i$ 的数（$i$ 在此取最大值）都在区间里，并且有 $j$ 个空位的区间数量

然后对这个数组进行第一维上的后缀求和，新数组 $cnt[i][j]$ 的意义就是数组中小于 $i$ 的数（$i$ 在此不一定是最大值，只是满足）都在区间里，并且有 $j$ 个空位的区间数量

然后对于 $cnt[i][j]$ ，如果空位数 $j$ 大于等于在 $i$ 前未出现在数组中的数的数量 $need[i]$，就可以排列组合出满足条件的区间，满足条件的区间数就是在 $j$ 个位置中选出 $need[i]$ 个，然后把这 $need[i]$ 个数与剩余的空位分别求排列数相乘，也就是：
$$
\binom{j}{need[i]}\times need[i]!\times (need[n]-need[i])!
$$
就这样就做完了

## 4.6 - 1 - [Problem - 1997E - Codeforces](https://codeforces.com/problemset/problem/1997/E)

#### 思路

不妨把条件做一下转化：

- 对于第 $i$ 只怪物，如果前面发生过至少 $k\times a_i$ 场战斗，那么怪物会逃跑，否则将发生战斗

那我们不难发现，对于任意时刻，$k$ 大的时候，此时的战斗力一定不会更强，这一点可以使用数学归纳法证明

那么我们只需要计算对于某个位置，$ans[i] $ 记录当 $k$ 至少为多少的时候，战斗无法避免

也就是说，对于 $k$ ，在这个位置之前发生的战斗数量就是此前 $ans[i]\le k$ 的 $i$ 的数量

对于每一个位置，我们可以用树状数组维护并实现查询 $ans[i]\le k$ 的 $i$ 的数量，从而二分求取此处的 $ans[i]$

那么就做完了

#### 收获&反思

很巧妙的转化思路，一些可能的思考启发是：

- 对于此类问题，考虑“什么东西具有单调性”，在此处是每个点处的战斗力与 $k$ 的关系，进而是每个怪物是否会发生战斗与 $k$ 的关系
- 然后就是树状数组的应用，应该考虑到答案可以以什么形式来存储并维护

## 4.7 - 1 - [Problem - D - Codeforces](https://codeforces.com/contest/1554/problem/D)

#### 思路

很巧妙的思路

对于 $n=1$ 特判

对于剩余情形：

- 若 $n$ 为偶数：
  - 我们令前 $\frac n2$ 个数与后 $\frac n2-1 $ 个数为`'a'` ，这样保证了所有仅由 `'a'` 组成的子串出现的次数均为奇数（前后出现次数相差一）
  - 然后令中间为其他任意字母即可
- 若 $n$ 为偶数
  - 与奇数处理方法类似，只不过中间两个字母为任意两个不同的其他字母

构造完毕

#### 收获&反思

题目不难，但是思路很优美

考虑构造一个东西是奇数，就可考虑构造两个部分，使得这两个部分一个是奇数，一个是偶数（特别地，可以使得两个部分相差一）即可

## 4.7 - 2 - [Problem - G - Codeforces](https://codeforces.com/contest/2000/problem/G)

#### 思路

很自然的想法是，我们无法确定什么时候可以出发，所以不确定通话在出发后多久开始，所以不妨将整个过程逆转，考虑从活动地点到家里的最短耗时，这样通话区间与出发时间的关系就是确定的了

我们考虑一个最快的流程应该是怎样的：

- 在通话开始前就可以到家
- 在通话开始前下车，在通话结束前步行到家
- 在通话开始前下车，在通话结束后步行或坐车到家

那我们就可以考虑分几个部分来解决问题：

- 先考虑在 $t_2$ 之前，坐车能到哪些位置，此时如果能直接到家则得到答案
- 然后新建一个图作为通话时的情形，建上所有步行边，同时从 $n$ 点向上述坐车能到达的点连一条有向边，长度即为花费的时间
- 再求一轮单源最短路，看看能不能步行到家
- 如果不能，我们就枚举打完电话后上车的位置，在打电话前花费的时间就是 $\max(dis,t_1)$ ，打电话后花费的时间就是坐车到家的最短开销

做完了

#### 启发

对每个过程都做贪心处理，用有限的枚举充分考虑所有情况

## 4.7 - 3 - [Problem - H - Codeforces](https://codeforces.com/contest/2044/problem/H)

#### 思路

用前缀和转化

一个是原矩阵的前缀和，一个是给所有数都乘上顺序权值的前缀和，还有一个给所有数按行乘上权值的前缀和

用这三个前缀和合理组合就可以计算出答案，没什么难的

#### 收获&反思

没什么好说的（才不会告诉你for循环写锅了一次）