# 3.3 逻辑运算符

## 概述

布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

- 取反运算符：`!`
- 且运算符：`&&`
- 或运算符：`||`
- Null 判断运算符：`??`（ES6 新增）

## 取反运算符 `!`

取反运算符是一个感叹号，用于将布尔值变为相反值，即 `true` 变成 `false`，`false` 变成 `true`。

```js
!true; // false
!false; // true
```

对于非布尔值，取反运算符会将其转为布尔值。

> [!note]
>
> 根据布尔强制类型转换的规则，只有下面 6 个值会转为 `false`，其余均为 `true`。因此，取反后得到 `true` 的只有下面 6 个：
>
> - `undefined`
> - `null`
> - `false`
> - `0`
> - `NaN`
> - `""`（空字符串）
>
> ```js
> !undefined; // true
> !null; // true
> !0; // true
> !NaN; // true
> !""; // true
>
> !54; // false
> !"hello"; // false
> ![]; // false
> !{}; // false
> ```

如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与 `Boolean` 函数的作用相同。这是一种常用的类型转换的写法。

```js
!!x;
// 等同于
Boolean(x);
```

上面代码中，不管 `x` 是什么类型的值，经过两次取反运算后，变成了与 `Boolean` 函数结果相同的布尔值。所以，两次取反就是将一个值转为布尔值的简便写法。

不过，把一个值转换为布尔型这件事本身没什么用处。毕竟像 `if` 这样的语句会自动将表达式转换为布尔型进行判断。

## 且运算符 `&&`

且运算符的运算规则是：如果第一个运算子的布尔值为 `true`，则返回第二个运算子的值（注意是**值**，**不是布尔值**）；如果第一个运算子的布尔值为 `false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。

显然，如果 `&&` 的两边都是布尔型的值，那么 `&&` 就是我们熟悉的二进制且运算。

```js
"t" && ""; // ""
"t" && "f"; // "f"
"t" && 1 + 2; // 3
"" && "f"; // ""
"" && ""; // ""

let x = 1;
false && x++; // 0
x; // 1
```

上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为 `false`，则直接返回它的值 `0`，而不再对第二个运算子求值，所以变量 `x` 的值没变。

> [!note]
>
> 这种跳过第二个运算子的机制，被称为“短路”。有些程序员喜欢用它取代 `if` 结构，比如下面是一段 `if` 结构的代码，就可以用且运算符改写。
>
> ```js
> if (i) {
>   doSomething();
> }
>
> // 等价于
>
> i && doSomething();
> ```
>
> 上面代码的两种写法是等价的，但是后一种可读性不佳。一般推荐使用 `if` 语句。

且运算符可以多个连用，这时返回第一个布尔值为 `false` 的表达式的值。如果所有表达式的布尔值都为 `true`，则返回最后一个表达式的值。

```js
true && "foo" && "" && 4 && "foo" && true;
// ''

1 && 2 && 3;
// 3
```

上面代码中，例一里面，第一个布尔值为 `false` 的表达式为第三个表达式，所以得到一个空字符串。例二里面，所有表达式的布尔值都是 `true`，所以返回最后一个表达式的值 `3`。

## 或运算符 `||`

或运算符（`||`）的运算规则是：如果第一个运算子的布尔值为 `true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为 `false`，则返回第二个运算子的值。

```js
"t" || ""; // "t"
"t" || "f"; // "t"
"" || "f"; // "f"
"" || ""; // ""
```

短路规则对这个运算符也适用。

```js
let x = 1;
true || x++; // true
x; // 1
```

或运算符可以多个连用，这时返回第一个布尔值为 `true` 的表达式的值。如果所有表达式都为 `false`，则返回最后一个表达式的值。

```js
false || 0 || "" || 4 || "foo" || true;
// 4

false || 0 || "";
// ''
```

## Null 判断运算符 `??`

或运算符常用于为一个变量设置缺省值。

```js
function saveText(text) {
  text = text || "";
  // ...
}

// 或者写成
saveText(this.text || "");
```

上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。

但是，这样的做法有一个问题。如果函数接受的值可能是除了 `undefined` 之外的其他假值呢？例如，动画的时长可以是 0：

```js
function setAnimationDuration(duration) {
  duration = duration || 300;
  // ...
}
setAnimationDuration(0); // 实际上设置的长度为 300
```

ES6 提供了新的 Null 判断运算符 `??`。其作用是判断第一个值是否为 `null` 或 `undefined`，如果是则返回后一个值，否则返回前一个值。

```js
let a;
a ?? 648; // 648
a = 328;
a ?? 648; // 328
a = 0;
a ?? 648; //0
```

> [!note]
>
> ES6 还引入了另外一种设置缺省值的方式。
>
> ```js
> function foo(arg = "default") {
>   console.log(arg);
> }
> foo("bar"); // bar
> foo(0); // 0
> foo(null); // null
> foo(); // default
> foo(undefined); // default
> ```
>
> 可见，这种方式比 `??` 更加严格：它接受 `null` 作为合法参数。
>
> 另外，这种方式也适用于解构赋值。
>
> ```js
> let a, b, c;
> [a = "defaultA", b = "defaultB", c = "defaultC"] = [1, , 3];
> a; // 1
> b; // 'defaultB'
> c; // 3
> ```

## 逻辑赋值运算符

ES6 引入了逻辑赋值运算符。

```js
// 或赋值运算符
x ||= y;
// 等同于
x || (x = y);

// 与赋值运算符
x &&= y;
// 等同于
x && (x = y);

// Null 赋值运算符
x ??= y;
// 等同于
x ?? (x = y);
```

不用说，最有用的当然是 `||=` 和 `??=`。`&&=` 基本用不上。
