# 3.4 位运算符

## 概述

二进制位运算符用于直接对二进制位进行计算，一共有 7 个。

- 按位或（or）：`|`
- 按位与（and）：`&`
- 按位非（not）：`~`
- 按位异或（xor）：`^`
- 左移（left shift）：`<<`
- 带符号右移（right shift）：`>>`
- 无符号右移（zero filled right shift）：`>>>`

这些位运算符直接处理每一个比特位（bit），是非常底层的运算，好处是速度极快，缺点是很不直观。

但是，众所周知，浮点数是无法执行位运算的，而之前我们[提过](../2-数据/2.3-数值和大整数#数值精度)，JavaScript 中所有的数字都是以浮点形式存储的。所以，JavaScript 中执行位运算的时候，会**先把数字转换为 32 位整数，然后再进行运算**。

可以利用这个特性，将任意数值转为 32 位整数。对于小数，小数部分会直接舍去。对于非数值，会先强制类型转换为数值。

```js
const toInt32 = (x) => x | 0;

toInt32(1); // 1
toInt32(1999.9); // 1999
toInt32(-5.5); // -5
toInt32(2147483647); // 2147483647
toInt32(2147483648); // -2147483648
toInt32(-2147483649); // 2147483647
toInt32(2 ** 32); // 0
```

## 重温整数

有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1 表示负数。数值范围从 -2147483648 到 2147483647。

可以以两种不同的方式存储二进制形式的有符号整数，一种用于存储正数，一种用于存储负数。正数是以真二进制形式存储的，前 31 位中的每一位都表示 2 的幂，从 0 号位开始，表示 $2^0$，1 号位表示 $2^1$。没用到的位用 0 填充，即忽略不计。例如，下图展示的是数 18 的表示法。

```mermaid
block-beta
    columns 32
    block:top:32
      t1(["数 18"])
    end
    b0["0"]
    b1["0"]
    b2["0"]
    b3["0"]
    b4["0"]
    b5["0"]
    b6["0"]
    b7["0"]
    b8["0"]
    b9["0"]
    b10["0"]
    b11["0"]
    b12["0"]
    b13["0"]
    b14["0"]
    b15["0"]
    b16["0"]
    b17["0"]
    b18["0"]
    b19["0"]
    b20["0"]
    b21["0"]
    b22["0"]
    b23["0"]
    b24["0"]
    b25["0"]
    b26["0"]
    b27["1"]
    b28["0"]
    b29["0"]
    b30["1"]
    b31["0"]
    l1["31"]:1
    block:b:26
    l2["<-- 过滤器 -->"]
    end
    space:4
    l3["0"]:1
style top fill:none,stroke:none
style t1 fill:none,stroke:none
style l1 fill:none,stroke-dasharray: 5 5
style b fill:none,stroke-dasharray: 5 5
style l2 fill:none,stroke:none
style l3 fill:none,stroke-dasharray: 5 5
```

把数字转换成二进制字符串，就能看到有效位：

```js
(18).toString(2); // "10010"
```

这段代码输出 `"10010"`，而不是 18 的 32 位表示，因为仅使用前 5 位即可确定这个十进制数值。

```mermaid
block-beta
  columns 5
  block:binary:5
  	b1["1"]
  	b2["0"]
  	b3["0"]
  	b4["1"]
  	b5["0"]
  end
  h1["1×2^4\n16"]
  h2["0×2^3\n0"]
  h3["0×2^2\n0"]
  h4["1×2^1\n2"]
  h5["0×2^0\n0"]
  total["Σ = 18"]:5
style binary fill:none
style h1 fill:none,stroke:none
style h2 fill:none,stroke:none
style h3 fill:none,stroke:none
style h4 fill:none,stroke:none
style h5 fill:none,stroke:none
style total fill:none,stroke:none
```

负数也存储为二进制代码，不过采用的形式是二进制补码。计算数字二进制补码的步骤有三步：

1. 确定该数字的非负版本的二进制表示（例如，要计算 `-18` 的二进制补码，首先要确定 `18` 的二进制表示）；
2. 求得二进制反码，即要把 `0` 替换为 `1`，把 `1` 替换为 `0`；
3. 在二进制反码上加 `1`。

要确定 `-18` 的二进制表示，首先必须得到 18 的二进制表示，如下所示：

```
0000 0000 0000 0000 0000 0000 0001 0010
```

接下来，计算二进制反码，如下所示：

```
1111 1111 1111 1111 1111 1111 1110 1101
```

最后，在二进制反码上加 1，如下所示：

```
1111 1111 1111 1111 1111 1111 1110 1101
+                                     1
---------------------------------------
1111 1111 1111 1111 1111 1111 1110 1110
```

因此，`-18` 的二进制表示即 `1111 1111 1111 1111 1111 1111 1110 1110`。

> [!note]
>
> ```js
> (-18).toString(2); // "10010"
> ```
>
> 这段代码输出的是 `"-10010"`，而非二进制补码。

## 按位或运算符

| 位 1 | 位 2 | 结果 |
| ---- | ---- | ---- |
| 1    | 1    | 1    |
| 1    | 0    | 1    |
| 0    | 1    | 1    |
| 0    | 0    | 0    |

按位或运算符（`|`）逐位比较两个运算子，两个二进制位之中只要有一个为 `1`，就返回 `1`，否则返回 `0`。

```js
25 | 3; // 27
```

运算过程：

```
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
OR = 0000 0000 0000 0000 0000 0000 0001 1011
```

> [!tip]
>
> 可以看出，任意 32 位整数与 0 作按位或，结果一定返回其本身。所以 `x | 0` 在 $\pm 2^{31}$ 内可以用于向下取整。不过，这样写可读性太差了。建议使用 JavaScript 提供的 `Math` 对象（我们将在 [4.7 Math 对象](../4-标准库/4.7-Math对象.md) 中详细介绍）。
>
> ```js
> Math.floor(3.7); // 3
> Math.ceil(6.2); // 7
> Math.round(3.55); // 4
> Math.round(3.45); // 3
> ```

## 按位与运算符

| 位 1 | 位 2 | 结果 |
| ---- | ---- | ---- |
| 1    | 1    | 1    |
| 1    | 0    | 0    |
| 0    | 1    | 0    |
| 0    | 0    | 0    |

按位与运算符（`&`）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为 `0`，就返回 `0`，否则返回 `1`。

```js
25 & 3; // 1
```

运算过程：

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001
```

## 按位非运算符

| 位  | 结果 |
| --- | ---- |
| 1   | 0    |
| 0   | 1    |

按位非运算符（`~`）也称按位取反运算符，将每个二进制位都变为相反值（`0` 变为 `1`，`1` 变为 `0`）。

```js
~25; // -26
```

可以看出，按位取反把符号位也一起处理了。

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
---------------------------------------------
NOT = 1111 1111 1111 1111 1111 1111 1110 0110
```

根据补码的运算规则，取反之后再加一即可得到原数字的相反数。

```js
const check = (x) => -x === ~x + 1;
check(0); // true
check(648); // true
check(-328); // true
```

> [!tip]
>
> 显然，两次取反会得到这个数本身。因此 `~~` 也用于取整。
>
> ```js
> ~~2.9; // 2
> ~~47.11; // 47
> ~~1.9999; // 1
> ~~-3.5; // -3
> ```
>
> 理论上，使用按位非运算取整是最快的。但是抛弃卡常数的思维吧，可读性和可维护性比那点性能重要得多，并且说不定引擎又做了什么优化（或者负优化）。

## 按位异或运算符

| 位 1 | 位 2 | 结果 |
| ---- | ---- | ---- |
| 1    | 1    | 0    |
| 1    | 0    | 1    |
| 0    | 1    | 1    |
| 0    | 0    | 0    |

异或运算（`^`）在两个二进制位不同时返回 `1`，相同时返回 `0`。

```js
25 ^ 3; // 26
```

运算过程：

```
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010
```

### 异或的特殊运用

这里我们讨论异或的几种特殊用法。但这些用法**通常可读性较差或者有其他问题**。仅仅是因为这样的做法被广泛应用，所以应当知晓。

#### 对布尔值取反

```js
1 | 1; // 0
0 | 1; // 1
```

由这个性质，我们可以将其用于布尔值的取反。

```js
let flag = true;
flag ^= 1;

if (flag) console.log("flag is true");
else console.log("flag is false");
// flag is false
```

其结果类似 `flag=!flag`，但是如果布尔值的名字很长，或者是一个属性时这种做法就有优越性了。

```js
someObject.someProperty.config.someConfigGroup.something ^= 1;
// 相比于
someObject.someProperty.config.someConfigGroup.something =
  !someObject.someProperty.config.someConfigGroup.something;
```

但是这种做法有个问题：`flag` 的类型会被改变。

```js
let flag = true;
typeof flag; // 'boolean'
flag ^= 1;
typeof flag; // 'number'
```

在 JavaScript 中这不是什么大问题。但是 TypeScript 这样严格检查类型的变体就会报错。

但 JavaScript 中没有按位或运算，因此这种做法甚至没有很好的替代。只能用 `flag=!flag`。真是一个悲伤的故事。

在 JavaScript 中，笔者认为这样的做法是可以推荐的，因为这种做法太常用了，以至于大家都懂，也没什么可读性问题了。

#### 交换两个变量的值

异或运算有一个特殊运用，连续对两个数 `a` 和 `b` 进行三次或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。其原理我们这里不展开，有兴趣请自行搜索。

```js
let a = 648,
  b = 114514;
(a ^= b), (b ^= a), (a ^= b);
a; // 114514
b; // 648
```

但是这样的做法可读性不佳，而且会损失精度。最佳实践是使用我们在 [2.7 数组](../2-数据/2.7-数组#解构) 提到的解构。

```js
let a = 648,
  b = 114514;
[a, b] = [b, a];
a; // 114514
b; // 648
```

#### 取整

异或运算也可以用来取整。

```js
12.9 ^ 0; // 12
```

## 左移运算符

```mermaid
block-beta
    columns 32
    block:top1:8
      t1(["符号位"])
    end
    block:top2:16
      t2["数字 2"]
    end
    space:8
    t1 --> b0
    b0["0"]
    b1["0"]
    b2["0"]
    b3["0"]
    b4["0"]
    b5["0"]
    b6["0"]
    b7["0"]
    b8["0"]
    b9["0"]
    b10["0"]
    b11["0"]
    b12["0"]
    b13["0"]
    b14["0"]
    b15["0"]
    b16["0"]
    b17["0"]
    b18["0"]
    b19["0"]
    b20["0"]
    b21["0"]
    b22["0"]
    b23["0"]
    b24["0"]
    b25["0"]
    b26["0"]
    b27["0"]
    b28["0"]
    b29["0"]
    b30["1"]
    b31["0"]
    block:top3:32
      t3["2 左移 5 位（数字 64）"]
    end
    t1 --> b0
    c0["0"]
    c1["0"]
    c2["0"]
    c3["0"]
    c4["0"]
    c5["0"]
    c6["0"]
    c7["0"]
    c8["0"]
    c9["0"]
    c10["0"]
    c11["0"]
    c12["0"]
    c13["0"]
    c14["0"]
    c15["0"]
    c16["0"]
    c17["0"]
    c18["0"]
    c19["0"]
    c20["0"]
    c21["0"]
    c22["0"]
    c23["0"]
    c24["0"]
    c25["1"]
    b30-->c25
    c26["0"]
    c27["0"]
    c28["0"]
    c29["0"]
    c30["0"]
    c31["0"]
    space:27
    block:top4:5
      t4["补 0"]
    end
style top1 fill:none,stroke:none
style top2 fill:none,stroke:none
style top3 fill:none,stroke:none
style top4 fill:none,stroke:none
style t1 fill:none,stroke-dasharray: 5 5
style t2 fill:none,stroke:none
style t3 fill:none,stroke:none
style t4 fill:none,stroke-dasharray: 5 5
```

左移运算符（`<<`）表示将一个数的二进制值向左移动指定的位数，尾部补 `0`，相当于乘以 `2` 的指定次方。向左移动的时候，**最高位的符号位是一起移动的**。

```js
let a = -(2 ** 31 - 1);
a; // -2147483647
a << 1; // 2
```

计算过程：

```
    a = 1000 0000 0000 0000 0000 0000 0000 0001
 a<<1 = 0000 0000 0000 0000 0000 0000 0000 0010
```

左移运算符用于二进制数值非常方便。下面的例子使用左移运算符，将颜色的 RGB 值转为 HEX 值。

```js
// RGB to HEX
const rgb2hex = (r, g, b) =>
  "#" +
  ((r << 16) + (g << 8) + b)
    .toString(16) // 先转成十六进制，然后返回字符串
    .padStart(6, "0"); // 高位补 0

let color = [186, 218, 85];
rgb2hex(...color);
// "#bada55"
```

> [!tip]
>
> 左移 0 位返回本身。因此 `<<0` 也用于取整。右移同理。

## 右移运算符

```mermaid
block-beta
    columns 32
    block:top1:8
      t1(["符号位"])
    end
    block:top2:16
      t2["数字 64"]
    end
    space:8
    t1 --> b0
    b0["0"]
    b1["0"]
    b2["0"]
    b3["0"]
    b4["0"]
    b5["0"]
    b6["0"]
    b7["0"]
    b8["0"]
    b9["0"]
    b10["0"]
    b11["0"]
    b12["0"]
    b13["0"]
    b14["0"]
    b15["0"]
    b16["0"]
    b17["0"]
    b18["0"]
    b19["0"]
    b20["0"]
    b21["0"]
    b22["0"]
    b23["0"]
    b24["0"]
    b25["1"]
    b26["0"]
    b27["0"]
    b28["0"]
    b29["0"]
    b30["0"]
    b31["0"]
    block:top3:32
      t3["64 带符号右移 5 位（数字 2）"]
    end
    t1 --> b0
    c0["0"]
    c1["0"]
    c2["0"]
    c3["0"]
    c4["0"]
    c5["0"]
    b0-->c5
    c6["0"]
    c7["0"]
    c8["0"]
    c9["0"]
    c10["0"]
    c11["0"]
    c12["0"]
    c13["0"]
    c14["0"]
    c15["0"]
    c16["0"]
    c17["0"]
    c18["0"]
    c19["0"]
    c20["0"]
    c21["0"]
    c22["0"]
    c23["0"]
    c24["0"]
    c25["0"]
    c26["0"]
    c27["0"]
    c28["0"]
    c29["0"]
    c30["1"]
    b25-->c30
    c31["0"]
    block:top4:5
      t4["补 0"]
    end
style top1 fill:none,stroke:none
style top2 fill:none,stroke:none
style top3 fill:none,stroke:none
style top4 fill:none,stroke:none
style t1 fill:none,stroke-dasharray: 5 5
style t2 fill:none,stroke:none
style t3 fill:none,stroke:none
style t4 fill:none,stroke-dasharray: 5 5
```

```mermaid
block-beta
    columns 32
    block:top1:8
      t1(["符号位"])
    end
    block:top2:16
      t2["数字 -64"]
    end
    space:8
    t1 --> b0
    b0["1"]
    b1["1"]
    b2["1"]
    b3["1"]
    b4["1"]
    b5["1"]
    b6["1"]
    b7["1"]
    b8["1"]
    b9["1"]
    b10["1"]
    b11["1"]
    b12["1"]
    b13["1"]
    b14["1"]
    b15["1"]
    b16["1"]
    b17["1"]
    b18["1"]
    b19["1"]
    b20["1"]
    b21["1"]
    b22["1"]
    b23["1"]
    b24["1"]
    b25["1"]
    b26["0"]
    b27["0"]
    b28["0"]
    b29["0"]
    b30["0"]
    b31["0"]
    block:top3:32
      t3["-64 带符号右移 5 位（数字 -2）"]
    end
    t1 --> b0
    c0["1"]
    c1["1"]
    c2["1"]
    c3["1"]
    c4["1"]
    c5["1"]
    b0-->c5
    c6["1"]
    c7["1"]
    c8["1"]
    c9["1"]
    c10["1"]
    c11["1"]
    c12["1"]
    c13["1"]
    c14["1"]
    c15["1"]
    c16["1"]
    c17["1"]
    c18["1"]
    c19["1"]
    c20["1"]
    c21["1"]
    c22["1"]
    c23["1"]
    c24["1"]
    c25["1"]
    c26["1"]
    c27["1"]
    c28["1"]
    c29["1"]
    c30["1"]
    c31["0"]
    b26-->c31
    block:top4:5
      t4["补 1"]
    end
style top1 fill:none,stroke:none
style top2 fill:none,stroke:none
style top3 fill:none,stroke:none
style top4 fill:none,stroke:none
style t1 fill:none,stroke-dasharray: 5 5
style t2 fill:none,stroke:none
style t3 fill:none,stroke:none
style t4 fill:none,stroke-dasharray: 5 5
```

带符号右移运算符（`>>`）简称右移运算符，表示将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补 `0`；如果是负数，头部全部补 `1`。右移运算符基本上相当于除以 `2` 的指定次方（最高位即符号位参与移动）。

右移运算可以模拟 2 的整除运算。

```js
5 >> 1;
// 2
// 相当于 5 / 2 = 2

21 >> 2;
// 5
// 相当于 21 / 4 = 5

21 >> 3;
// 2
// 相当于 21 / 8 = 2

21 >> 4;
// 1
// 相当于 21 / 16 = 1
```

## 头部补零的右移运算符

```mermaid
block-beta
    columns 32
    block:top1:8
      t1(["符号位"])
    end
    block:top2:16
      t2["数字 64"]
    end
    space:8
    t1 --> b0
    b0["0"]
    b1["0"]
    b2["0"]
    b3["0"]
    b4["0"]
    b5["0"]
    b6["0"]
    b7["0"]
    b8["0"]
    b9["0"]
    b10["0"]
    b11["0"]
    b12["0"]
    b13["0"]
    b14["0"]
    b15["0"]
    b16["0"]
    b17["0"]
    b18["0"]
    b19["0"]
    b20["0"]
    b21["0"]
    b22["0"]
    b23["0"]
    b24["0"]
    b25["1"]
    b26["0"]
    b27["0"]
    b28["0"]
    b29["0"]
    b30["0"]
    b31["0"]
    block:top3:32
      t3["64 无符号右移 5 位（数字 2）"]
    end
    t1 --> b0
    c0["0"]
    c1["0"]
    c2["0"]
    c3["0"]
    c4["0"]
    c5["0"]
    b0-->c5
    c6["0"]
    c7["0"]
    c8["0"]
    c9["0"]
    c10["0"]
    c11["0"]
    c12["0"]
    c13["0"]
    c14["0"]
    c15["0"]
    c16["0"]
    c17["0"]
    c18["0"]
    c19["0"]
    c20["0"]
    c21["0"]
    c22["0"]
    c23["0"]
    c24["0"]
    c25["0"]
    c26["0"]
    c27["0"]
    c28["0"]
    c29["0"]
    c30["1"]
    b25-->c30
    c31["0"]
    block:top4:5
      t4["补 0"]
    end
style top1 fill:none,stroke:none
style top2 fill:none,stroke:none
style top3 fill:none,stroke:none
style top4 fill:none,stroke:none
style t1 fill:none,stroke-dasharray: 5 5
style t2 fill:none,stroke:none
style t3 fill:none,stroke:none
style t4 fill:none,stroke-dasharray: 5 5
```

```mermaid
block-beta
    columns 32
    block:top1:8
      t1(["符号位"])
    end
    block:top2:16
      t2["数字 -64"]
    end
    space:8
    t1 --> b0
    b0["1"]
    b1["1"]
    b2["1"]
    b3["1"]
    b4["1"]
    b5["1"]
    b6["1"]
    b7["1"]
    b8["1"]
    b9["1"]
    b10["1"]
    b11["1"]
    b12["1"]
    b13["1"]
    b14["1"]
    b15["1"]
    b16["1"]
    b17["1"]
    b18["1"]
    b19["1"]
    b20["1"]
    b21["1"]
    b22["1"]
    b23["1"]
    b24["1"]
    b25["1"]
    b26["0"]
    b27["0"]
    b28["0"]
    b29["0"]
    b30["0"]
    b31["0"]
    block:top3:32
      t3["-64 无符号右移 5 位（数字 134217726）"]
    end
    t1 --> b0
    c0["0"]
    c1["0"]
    c2["0"]
    c3["0"]
    c4["0"]
    c5["1"]
    b0-->c5
    c6["1"]
    c7["1"]
    c8["1"]
    c9["1"]
    c10["1"]
    c11["1"]
    c12["1"]
    c13["1"]
    c14["1"]
    c15["1"]
    c16["1"]
    c17["1"]
    c18["1"]
    c19["1"]
    c20["1"]
    c21["1"]
    c22["1"]
    c23["1"]
    c24["1"]
    c25["1"]
    c26["1"]
    c27["1"]
    c28["1"]
    c29["1"]
    c30["1"]
    c31["0"]
    b26-->c31
    block:top4:5
      t4["补 0"]
    end
style top1 fill:none,stroke:none
style top2 fill:none,stroke:none
style top3 fill:none,stroke:none
style top4 fill:none,stroke:none
style t1 fill:none,stroke-dasharray: 5 5
style t2 fill:none,stroke:none
style t3 fill:none,stroke:none
style t4 fill:none,stroke-dasharray: 5 5
```

无符号右移运算符（`>>>`）也称头部补零的右移运算符，与右移运算符（`>>`）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（`>>`）完全一致，区别主要在于负数。

**并且这个运算返回值时，将这 32 位解读为无符号整数**。

```js
-1 >>> 0; // 4294967295
```

这也是查看一个负整数在计算机内部的储存形式最快的方法。上面代码表示，`-1` 作为 32 位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即 $2^{32}-1$）。

> [!note]
>
> **上古科技：位运算与开关**
>
> 位运算符可以用作设置对象属性的开关。用来做属性设置或者权限控制之类的。
>
> 假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。
>
> ```js
> const FLAG_A = 0b0001;
> const FLAG_B = 0b0010;
> const FLAG_C = 0b0100;
> const FLAG_D = 0b1000;
> ```
>
> 上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。
>
> 然后，就可以用按位与运算，检查当前设置是否打开了指定开关。
>
> ```js
> let flags = 0b0101;
>
> if (flags & FLAG_C) {
>   // ...
> }
> // 0101 & 0100 => 0100 => true
> ```
>
> 上面代码检验是否打开了开关 `C`。如果打开，会返回 `true`，否则返回 `false`。
>
> 现在假设需要打开 `A`、`B`、`D` 三个开关，我们可以构造一个掩码变量。
>
> ```js
> let mask = FLAG_A | FLAG_B | FLAG_D;
> // 0001 | 0010 | 1000 = 1011
> ```
>
> 上面代码对 `A`、`B`、`D` 三个变量进行按位或运算，得到掩码值为二进制的 `1011`。
>
> 有了掩码，按位或运算可以确保打开指定的开关。
>
> ```js
> flags = flags | mask;
> ```
>
> 上面代码中，计算后得到的 `flags` 变量，代表三个开关的二进制位都打开了。
>
> 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。
>
> ```js
> flags = flags & mask;
> ```
>
> 异或运算可以切换当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。
>
> ```js
> flags = flags ^ mask;
> ```
>
> 按位非运算可以翻转当前设置，即原设置为 `0`，运算后变为 `1`；原设置为 `1`，运算后变为 `0`。
>
> ```js
> flags = ~flags;
> ```
>
> 显然，这样的做法可维护性非常糟糕。最佳实践是使用后续的面向对象方式来实现。
