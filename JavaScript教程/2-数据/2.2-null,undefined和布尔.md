# 2.2 null, undefined 和布尔值

## null 和 undefined

JavaScript 有个比较糟糕的地方：它有两个「空」，这在编程语言里绝无仅有。

`null` 与 `undefined` 都可以表示「没有」，含义非常相似。将一个变量赋值为 `undefined` 或 `null`，老实说，语法效果几乎没区别。

在 `if` 语句中，它们都会被自动转为 `false`，相等运算符（`==`）甚至直接报告两者相等。

```js
if (!undefined) {
  console.log("undefined is false");
}
// undefined is false

if (!null) {
  console.log("null is false");
}
// null is false

undefined == null;
// true
```

从上面代码可见，两者的行为十分相似。谷歌公司开发的 JavaScript 语言的替代品 Dart 语言，就明确规定只有 `null`，没有 `undefined`。

既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。

1995 年 JavaScript 诞生时，最初像 Java 一样，只设置了 `null` 表示「无」。根据 C 语言的传统，`null` 可以自动转为 `0`。

```js
Number(null); // 0
5 + null; // 5
```

上面代码中，`null` 转为数字时，自动变成 0。

但是，JavaScript 的设计者 Brendan Eich，觉得这样做还不够。首先，第一版的 JavaScript 里面，`null` 就像在 Java 里一样，被当成一个对象，Brendan Eich 觉得表示「无」的值最好不是对象。其次，那时的 JavaScript 不包括错误处理机制，Brendan Eich 觉得，如果 `null` 自动转为 0，很不容易发现错误。

因此，他又设计了一个 `undefined`。区别是这样的：`null` 是一个表示「空」的对象，转为数值时为 `0`；`undefined` 是一个表示"此处无定义"的原始值，转为数值时为 `NaN`。

```js
Number(undefined); // NaN
5 + undefined; // NaN
```

通常，和引擎相关的事情和 `undefined` 相关，和标准库相关的事情会和 `null` 有关。当然，也不绝对。

下面是返回 `undefined` 的典型场景。

```js
// 变量声明了，但没有赋值
var i;
i; // undefined

// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
function f(x) {
  return x;
}
f(); // undefined

// 对象没有赋值的属性
var o = new Object();
o.p; // undefined

// 函数没有返回值时，默认返回 undefined
function f() {}
f(); // undefined
```

至于各种查询方法在没找到时返回的到底是 `undefined`、`null` 还是空数组，没有必要记忆，用的时候去控制台上试一试即可。

## 布尔 Boolean

布尔值（Boolean 类型）是 JavaScript 中最常用的类型之一。它有两个值 `true` 和 `false`（即两个布尔字面量）。

即使 `false` 不等于 `0`，`0` 也可以在必要时被转换成 `false`，这样在 Boolean 语句中使用两者都是安全的。

下列运算符会返回布尔值：

- 前置逻辑运算符： `!` (Not)
- 相等运算符：`===`，`!==`，`==`，`!=`
- 比较运算符：`>`，`>=`，`<`，`<=`

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 `false`，其他值都视为 `true`。

- `undefined`
- `null`
- `false`
- `0`（包括 `+0` 和 `-0`）
- `NaN`
- `""`（空字符串）

> [!warning]
>
> 空数组（`[]`）和空对象（`{}`）对应的布尔值，都是 `true`。
>
> 也就是说，任何 `typeof` 输出 `object` 的东西，除了 `null`，都是真值。因此，不少教程将 `null` 认为是对象的占位符，这是不正确的，`null` 就是 `null`，不是对象。
